package nl.uu.cs.ape.sat.core.implSAT;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import nl.uu.cs.ape.sat.core.SolutionInterpreter;
import nl.uu.cs.ape.sat.core.solutionStructure.SolutionWorkflow;
import nl.uu.cs.ape.sat.models.AtomMappings;
import nl.uu.cs.ape.sat.utils.APEConfig;
/**
 *  The {@code All_solutions} class is used to store all the SAT solutions generated by the program, 
 *  together with the corresponding mappings.
 *  
 * @author Vedran Kasalica
 *
 */
public class AllSATsolutions {

	/** List representing all solution workflows. */
	private List<SolutionWorkflow> solutionWorkflows;
	/** Max number of solutions that should be found. */
	private int maxSolutions;
	/** Mapping of predicates into integers (for SAT encoding). */
	private AtomMappings mappings;

	/**
	 * Create an object that will contain all the solutions of the synthesis.
	 * @param config - setup configuration for the synthesis.
	 */
	public AllSATsolutions(APEConfig config) {
		solutionWorkflows = new ArrayList<SolutionWorkflow>();
		
		/** Provides mapping from each atom to a number, and vice versa */
		mappings = new AtomMappings();
		/*
		 * Variables defining the current and maximum lengths and solutions count.
		 */
		maxSolutions = config.getMax_no_solutions();
		if(maxSolutions > 1000) {
			System.out.println("Looking for " + maxSolutions + " solutions might take some time.");
		}
	}

	/**
	 * Get all the solutions that are currently found.
	 * @return List of {@link SolutionWorkflow solution} objects
	 */
	public List<SolutionWorkflow> getSolutions() {
		return solutionWorkflows;
	}

	/** 
	 * Get the number of solutions that are currently found.
	 * @return Number of solutions in the solutions set.
	 */
	public int getNumberOfSolutions() {
		return solutionWorkflows.size();
	}

	/**
	 * Get max number of solutions that should be found. This number is defined in the ape.config file.
	 * @return Max number of solutions that should be found.
	 */
	public int getMaxNumberOfSolutions() {
		return maxSolutions;
	}

	/**
	 * Get object that contains mappings of all the atoms.
	 * @return {@link AtomMappings} object.
	 */
	public AtomMappings getMappings() {
		return mappings;
	}
	/**
	 * Returns true if the list of all the solutions contains no elements.
	 * @return {@code true} if the list contains no elements
	 */
	public boolean isEmpty() {
		return solutionWorkflows.isEmpty();
	}
	
	/**
	 * The procedure resets the encodings specific for a synthesis run (such as auxiliary variables).
	 */
	public void newEncoding() {
		mappings.resetAuxVariables();
	}

	/**
	 * Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
	 * 
	 * @param currSolutions - solutions that should be added to the list of all solutions
	 * @return {@code true} if this list changed as a result of the call
	 */
	public boolean addSolutions(List<SolutionWorkflow> currSolutions) {
		if(solutionWorkflows.addAll(currSolutions)) {
			return true;
		}
		return false;
	}


	public SolutionWorkflow get(int index) {
		return solutionWorkflows.get(index);
	}
}
