package nl.uu.cs.ape.sat.models;

import java.util.ArrayList;
import java.util.List;

import org.dom4j.Node;
import org.json.JSONException;
import org.json.JSONObject;

import nl.uu.cs.ape.sat.models.enums.NodeType;
import nl.uu.cs.ape.sat.utils.APEConfig;
import nl.uu.cs.ape.sat.utils.APEUtils;

/**
 * The {@code Module} class represents concrete modules/tools that can be used
 * in our program. It must be annotated using the proper Input/Output pair
 * provided by the tool annotation file.
 * 
 * @author Vedran Kasalica
 *
 */
public class Module extends AbstractModule {

	/** List of input types required by the tool. */
	private List<DataInstance> moduleInput;
	/** List of output types generated by the tool. */
	private List<DataInstance> moduleOutput;
	/** Tool execution engine - TODO */
	private Module_Execution moduleExecution;

	/**
	 * Constructs a new Module with already defined lists of input and output types.
	 * 
	 * @param moduleName   - Module name
	 * @param moduleID     - Module ID
	 * @param rootNode     - ID of the Taxonomy Root associated with the Module
	 * @param moduleInput  - list of the INPUT types/formats
	 * @param moduleOutput - list of the OUTPUT types/formats
	 */
	public Module(String moduleName, String moduleID, String rootNode, List<DataInstance> moduleInput,
			List<DataInstance> moduleOutput, Module_Execution moduleExecution) {
		super(moduleName, moduleID, rootNode, NodeType.LEAF);
		this.moduleInput = new ArrayList<DataInstance>(moduleInput);
		this.moduleOutput = new ArrayList<DataInstance>(moduleOutput);
		this.moduleExecution = moduleExecution;
	}

	/**
	 * Constructs a new Module with empty lists of input and output types/formats.
	 * 
	 * @param moduleName - module name
	 * @param moduleID   - unique module identifier
	 * @param rootNode   - ID of the Taxonomy Root node corresponding to the Module.
	 */
	public Module(String moduleName, String moduleID, String rootNode, Module_Execution moduleExecution) {
		super(moduleName, moduleID, rootNode, NodeType.LEAF);
		this.moduleInput = new ArrayList<DataInstance>();
		this.moduleOutput = new ArrayList<DataInstance>();
		this.moduleExecution = moduleExecution;
	}

	/**
	 * Constructor used to override an existing AbstractModule with a new Module.
	 * 
	 * @param module         - New created Module.
	 * @param abstractModule - Existing AbstractModule that is to be extended with
	 *                       all the fields from the Module.
	 */
	public Module(Module module, AbstractModule abstractModule) {
		super(abstractModule, NodeType.LEAF);
		this.moduleInput = module.getModuleInput();
		this.moduleOutput = module.getModuleOutput();
		this.moduleExecution = module.getModuleExecution();
	}

	public int hashCode() {
		return super.hashCode();
	}

	public boolean equals(Object obj) {
		return super.equals(obj);
	}

	/**
	 * Returns the list (possibly empty) of required input types for the module.
	 * Returns null in the case of abstract classes, as they do not have input
	 * types.
	 * 
	 * @return List of input types (tool modules) or null (non-tool/abstract
	 *         modules)
	 */
	@Override
	public List<DataInstance> getModuleInput() {
		return moduleInput;
	}

	public void setModuleInput(List<DataInstance> moduleInputs) {
		this.moduleInput = moduleInputs;
	}

	/**
	 * Appends the specified element to the end of the input list (optional
	 * operation).
	 * 
	 * @param moduleInput - element to be appended to this list
	 */
	public void addModuleInput(DataInstance moduleInput) {
		this.moduleInput.add(moduleInput);
	}

	/**
	 * Returns the list (possibly empty) of required output types for the module.
	 * Returns null in the case of abstract classes, as they do not have output
	 * types.
	 * 
	 * @return List of output types (tool modules) or null (non-tool/abstract
	 *         modules)
	 */
	@Override
	public List<DataInstance> getModuleOutput() {
		return moduleOutput;
	}

	public void setModuleOutput(List<DataInstance> moduleOutput) {
		this.moduleOutput = moduleOutput;
	}

	/**
	 * Appends the specified element to the end of the output list (optional
	 * operation).
	 * 
	 * @param moduleInput - element to be appended to this list
	 */
	public void addModuleOutput(DataInstance moduleOutput) {
		this.moduleOutput.add(moduleOutput);
	}

	/**
	 * Return the object that implements the execution of the Module. {@code null}
	 * in case of it not having an implementation.
	 * 
	 * @return {@code Module_Execution} object or {@code null} if the module does
	 *         not have an implementation.
	 */
	public Module_Execution getModuleExecution() {
		return this.moduleExecution;
	}

	static int id = 1;

	/**
	 * Creates a module from a tool annotation instance represented in XML.
	 * 
	 * @param xmlModule  - xml representation of a module
	 * @param allModules - list of all the modules
	 * @param allTypes   - list of all the types
	 * @return Module object.
	 */
	public static Module moduleFromXML(Node xmlModule, AllModules allModules, AllTypes allTypes) {

		String superModuleID = xmlModule.selectSingleNode("operation").getText();
		/** Determines whether the superModule exists in the tool taxonomy */
		boolean superModuleExists = allModules.get(superModuleID) != null;
		/** Determines whether the superModule is the root or an abstract tool. */
		boolean superModuleIsRoot;
		String moduleName = xmlModule.valueOf("@name");
		String moduleID = moduleName;

		/* If the superModule exists in the taxonomy */
		if (superModuleExists) {
			/*
			 * and the module name was not uniquely specified. The name is defined based on
			 * the "operation" specified
			 */
			if (moduleID == null || moduleID.matches("") || superModuleID.matches(moduleID)) {
				moduleID = superModuleID + "_ID:" + (id++);
				moduleName = superModuleID;
			}
			superModuleIsRoot = false;
		} /* If the superModule does not exist in the taxonomy */
		else {
			/**
			 * but is distinguished from the tool implementation. The superModule should be
			 * created.
			 */
			if (!superModuleID.matches(moduleID)) {
				superModuleIsRoot = false;
			}
			/**
			 * and is not distinguished from the tool implementation. The superModule should
			 * not be created, and the root is considered to be the superModule.
			 */
			else {
				moduleID = superModuleID;
				moduleName = superModuleID;
				superModuleIsRoot = true;
			}
		}
		if (moduleID == null || moduleID.matches("") || (superModuleExists && superModuleID.matches(moduleID))) {
			moduleID = superModuleID + "_ID:" + (id++);
			moduleName = superModuleID;
		}
		String executionCode = xmlModule.selectSingleNode("implementation").selectSingleNode("code").getText();

//		BIO tools 
//		String moduleName = xmlModule.selectSingleNode("displayName").getText();
//		String moduleID = xmlModule.selectSingleNode("displayName").getText();
		List<Node> xmlModuleInput = xmlModule.selectNodes("inputs/input");
		List<Node> xmlModuleOutput = xmlModule.selectNodes("outputs/output");

		List<DataInstance> inputs = new ArrayList<DataInstance>();
		List<DataInstance> outputs = new ArrayList<DataInstance>();

		for (Node xmlInput : xmlModuleInput) {
			if (xmlInput.hasContent()) {
				DataInstance input = new DataInstance();
				for (Node xmlType : xmlInput.selectNodes("*")) {
					if (allTypes.get(xmlType.getText()) == null) {
						System.err.println("Data format \"" + xmlType.getText()
								+ "\" used in the tool annotations does not exist in the data taxonomy. This might influence the validity of the solutions.");
					}
					Type tmpType = allTypes.addType(xmlType.getText(), xmlType.getText(),
							allTypes.getRootID(), NodeType.UNKNOWN, allTypes.getRootType());
					if (tmpType != null) {
						input.addType(tmpType);
						allTypes.addAnnotatedType(tmpType.getPredicateID());
					}
				}
				inputs.add(input);
			}
		}

		for (Node xmlOutput : xmlModuleOutput) {
			if (xmlOutput.hasContent()) {
				DataInstance output = new DataInstance();
				for (Node xmlType : xmlOutput.selectNodes("*")) {
					if (allTypes.get(xmlType.getText()) == null) {
						System.err.println("Data format \"" + xmlType.getText()
								+ "\" used in the tool annotations does not exist in the data taxonomy. This might influence the validity of the solutions.");
					}
					Type tmpType = allTypes.addType(xmlType.getText(), xmlType.getText(),
							allTypes.getRootID(), NodeType.UNKNOWN, allTypes.getRootType());
					if (tmpType != null) {
						output.addType(tmpType);
						allTypes.addAnnotatedType(tmpType.getPredicateID());
					}
				}
				outputs.add(output);
			}
		}

		Module_Execution moduleExecutionImpl = null;
		if (executionCode != null && !executionCode.matches("")) {
			moduleExecutionImpl = new Module_Execution_Code(executionCode);
		}

		AbstractModule currSuperModule;

		if (!superModuleExists) {
			System.err.println("Annotated tool \"" + superModuleID
					+ "\" does not exists in the Tool Taxonomy. It is added as a direct subclass of the root in the Tool Taxonomy.");
		}
		/*
		 * In case of the tool is an instance of the abstract superModule, add it as a
		 * sub module (enrich the ontology). Depending of the superModuleID.
		 * currSuperModule is an AbstractModule or the Module Taxonomy root. In case
		 * that the
		 */
		if (!superModuleIsRoot) {
			AbstractModule superModule = AbstractModule.generateModule(superModuleID, superModuleID,
					allModules.getRootID(), NodeType.ABSTRACT, allModules,
					allModules.getRootModule());
			/*
			 * If the super module is represented as a tool, convert it to abstract module
			 */
			if (superModule instanceof Module) {
				AbstractModule newSuperModule = new AbstractModule(superModule, NodeType.ABSTRACT);
				allModules.swapAbstractModule2Module(newSuperModule, superModule);
				currSuperModule = newSuperModule;
			} else {
				superModule.setNodeType(NodeType.ABSTRACT);
				currSuperModule = superModule;
			}
		} else {
			currSuperModule = allModules.getRootModule();
		}

		/*
		 * Add the module and make it sub module of the currSuperModule (if it was not
		 * previously defined)
		 */
		Module currModule = Module.generateModule(moduleName, moduleID, allModules.getRootID(),
				allModules, currSuperModule, moduleExecutionImpl);
		currModule.setModuleInput(inputs);
		currModule.setModuleOutput(outputs);

		return currModule;
	}

	/**
	 * Creates a module from a tool annotation instance from a Json file.
	 * 
	 * @param jsonModule - Json representation of a module
	 * @param allModules - list of all the modules
	 * @param allTypes   - list of all the types
	 * @return New Module object.
	 */
	public static Module moduleFromJson(JSONObject jsonModule, AllModules allModules, AllTypes allTypes)
			throws JSONException {

		String superModuleID = jsonModule.getString(APEConfig.getConstraintTags("id"));
		/** Determines whether the superModule exists in the tool taxonomy */
		boolean superModuleExists = allModules.get(superModuleID) != null;
		/** Determines whether the superModule is the root or an abstract tool. */
		boolean superModuleIsRoot;
		String moduleName = jsonModule.getString(APEConfig.getConstraintTags("label"));
		String moduleID = moduleName;

		/* If the superModule exists in the taxonomy */
		if (superModuleExists) {
			/*
			 * and the module name was not uniquely specified. The name is defined based on
			 * the "operation" specified
			 */
			if (moduleID == null || moduleID.matches("") || superModuleID.matches(moduleID)) {
				moduleID = superModuleID + "_ID:" + (id++);
				moduleName = superModuleID;
			}
			superModuleIsRoot = false;
		} /* If the superModule does not exist in the taxonomy */
		else {
			/**
			 * but is distinguished from the tool implementation. The superModule should be
			 * created.
			 */
			if (!superModuleID.matches(moduleID)) {
				superModuleIsRoot = false;
			}
			/**
			 * and is not distinguished from the tool implementation. The superModule should
			 * not be created, and the root is considered to be the superModule.
			 */
			else {
				moduleID = superModuleID;
				moduleName = superModuleID;
				superModuleIsRoot = true;
			}
		}
		if (moduleID == null || moduleID.matches("") || (superModuleExists && superModuleID.matches(moduleID))) {
			moduleID = superModuleID + "_ID:" + (id++);
			moduleName = superModuleID;
		}
		String executionCode = null;
		try {
			executionCode = jsonModule.getJSONObject(APEConfig.getConstraintTags("implementation"))
					.getString(APEConfig.getConstraintTags("code"));
		} catch (JSONException e) {
			/* Skip the execution code */}
//		BIO tools 
//		String moduleName = xmlModule.selectSingleNode("displayName").getText();
//		String moduleID = xmlModule.selectSingleNode("displayName").getText();
		List<JSONObject> jsonModuleInput = APEUtils.getListFromJson(jsonModule, APEConfig.getConstraintTags("inputs"),
				JSONObject.class);
		List<JSONObject> jsonModuleOutput = APEUtils.getListFromJson(jsonModule, APEConfig.getConstraintTags("outputs"),
				JSONObject.class);

		List<DataInstance> inputs = new ArrayList<DataInstance>();
		List<DataInstance> outputs = new ArrayList<DataInstance>();

		for (JSONObject jsonInput : jsonModuleInput) {
			if (!jsonInput.isEmpty()) {
				DataInstance input = new DataInstance();
				for (String typeSubntology : jsonInput.keySet()) {
					for (String currType : APEUtils.getListFromJson(jsonInput, typeSubntology, String.class)) {
						if (allTypes.get(currType) == null) {
							System.err.println("Data format \"" + currType
									+ "\" used in the tool annotations does not exist in the data taxonomy. This might influence the validity of the solutions.");
						}
						if (allTypes.getDataTaxonomyDimensions().contains(typeSubntology)) {
							Type tmpType = allTypes.addType(currType, currType, typeSubntology, NodeType.UNKNOWN,
									allTypes.getRootType());
							if (tmpType != null) {
								input.addType(tmpType);
								allTypes.addAnnotatedType(tmpType.getPredicateID());
							}
						} else {
							new JSONException(
									"Error in the tool annotation file . The data subtaxonomy '" + typeSubntology
											+ "' was not defined, but it was used for input type '" + currType + "'.");
						}
					}
				}
				inputs.add(input);
			}
		}

		for (JSONObject jsonOutput : jsonModuleOutput) {
			if (!jsonOutput.isEmpty()) {
				DataInstance output = new DataInstance();
				for (String typeSubntology : jsonOutput.keySet()) {
					for (String currType : APEUtils.getListFromJson(jsonOutput, typeSubntology, String.class)) {
						if (allTypes.get(currType.toString()) == null) {
							System.err.println("Data format \"" + currType.toString()
									+ "\" used in the tool annotations does not exist in the data taxonomy. This might influence the validity of the solutions.");
						}
						if (allTypes.getDataTaxonomyDimensions().contains(typeSubntology)) {
							Type tmpType = allTypes.addType(currType.toString(), currType.toString(), typeSubntology,
									NodeType.UNKNOWN, allTypes.getRootType());
							if (tmpType != null) {
								output.addType(tmpType);
								allTypes.addAnnotatedType(tmpType.getPredicateID());
							}
						} else {
							new JSONException(
									"Error in the tool annotation file . The data subtaxonomy '" + typeSubntology
											+ "' was not defined, but it was used for output type '" + currType + "'.");
						}
					}
				}
				outputs.add(output);
			}
		}

		Module_Execution moduleExecutionImpl = null;
		if (executionCode != null && !executionCode.matches("")) {
			moduleExecutionImpl = new Module_Execution_Code(executionCode);
		}

		AbstractModule currSuperModule;

		if (!superModuleExists) {
			System.err.println("Annotated tool \"" + superModuleID
					+ "\" does not exists in the Tool Taxonomy. It is added as a direct subclass of the root in the Tool Taxonomy.");
		}
		/*
		 * In case of the tool is an instance of the abstract superModule, add it as a
		 * sub module (enrich the ontology). Depending of the superModuleID.
		 * currSuperModule is an AbstractModule or the Module Taxonomy root. In case
		 * that the
		 */
		if (!superModuleIsRoot) {
			AbstractModule superModule = AbstractModule.generateModule(superModuleID, superModuleID,
					allModules.getRootID(), NodeType.ABSTRACT, allModules,
					allModules.getRootModule());
			/*
			 * If the super module is represented as a tool, convert it to abstract module
			 */
			if (superModule instanceof Module) {
				AbstractModule newSuperModule = new AbstractModule(superModule, NodeType.ABSTRACT);
				allModules.swapAbstractModule2Module(newSuperModule, superModule);
				currSuperModule = newSuperModule;
			} else {
				superModule.setNodeType(NodeType.ABSTRACT);
				currSuperModule = superModule;
			}
		} else {
			currSuperModule = allModules.getRootModule();
		}

		/*
		 * Add the module and make it sub module of the currSuperModule (if it was not
		 * previously defined)
		 */
		Module currModule = Module.generateModule(moduleName, moduleID, allModules.getRootID(),
				allModules, currSuperModule, moduleExecutionImpl);
		currModule.setModuleInput(inputs);
		currModule.setModuleOutput(outputs);

		return currModule;
	}

	/**
	 * Return a printable String version of the module.
	 * 
	 * @return module as printable String
	 */
	@Override
	public String print() {
		StringBuilder inputs = new StringBuilder();
		StringBuilder outputs = new StringBuilder();

		for (DataInstance types : moduleInput) {
			inputs = inputs.append("{ ");
			for (Type type : types.getTypes()) {
				inputs = inputs.append("'").append(type.getPredicateLabel()).append("' ");
			}
			inputs = inputs.append("} ");
		}
		for (DataInstance types : moduleOutput) {
			outputs = outputs.append("{ ");
			for (Type type : types.getTypes()) {
				outputs = outputs.append("'").append(type.getPredicateLabel()).append("' ");
			}
			outputs = outputs.append("} ");
		}

		return "______________________________________\n|" + super.print() + ",\n|IN:\t" + inputs + ",\n|OUT\t"
				+ outputs + "\n|______________________________________";
	}

	/**
	 * Print the ID of the Module with a label [T] in the end (denoting Tool)
	 * 
	 * @return Module ID
	 */
	@Override
	public String printShort() {
		return super.printShort() + "[T]";
	}

	@Override
	public String getType() {
		return "module";
	}

	/**
	 * The class is used to check weather the Module with @moduleID was already
	 * introduced earlier on in @allModules. In case it was defined as
	 * {@literalModule} it returns the item, in case of it being introduced as an
	 * AbstractModule, it is extended to a Module and returned, otherwise the new
	 * element is generated and returned. <br>
	 * <br>
	 * In case of generating a new Module, the object is added to the set of all the
	 * Modules and added as a subModule to the parent Module.
	 * 
	 * @param moduleName - Module name.
	 * @param moduleID   - Unique module identifier.
	 * @param rootNode   - ID of the Taxonomy Root node corresponding to the Module.
	 * @param allModules - Set of all the modules created so far.
	 * @return The Module representing the item.
	 */
	public static Module generateModule(String moduleName, String moduleID, String rootNode, AllModules allModules,
			AbstractModule superModule, Module_Execution moduleExecution) {

		// In case of generating a new Module, the object is added as a subModule to the
		// parent Module.
		if (superModule != null) {
			superModule.addSubModule(moduleID);
		}
		AbstractModule currModule = allModules.addModule(new Module(moduleName, moduleID, rootNode, moduleExecution));

		return (Module) currModule;
	}

}
