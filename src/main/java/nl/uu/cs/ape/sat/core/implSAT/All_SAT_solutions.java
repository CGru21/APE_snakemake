package nl.uu.cs.ape.sat.core.implSAT;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import nl.uu.cs.ape.sat.core.SolutionInterpreter;
import nl.uu.cs.ape.sat.core.solutionStructure.SolutionWorkflow;
import nl.uu.cs.ape.sat.models.AtomMapping;
import nl.uu.cs.ape.sat.utils.APEConfig;
/**
 *  The {@code All_solutions} class is used to store all the SAT solutions generated by the program, 
 *  together with the corresponding mappings.
 *  
 * @author Vedran Kasalica
 *
 */
public class All_SAT_solutions {

	private List<SolutionWorkflow> solutionWorkflow;
	private int solutionsFoundMax;
	private AtomMapping mappings;

	/**
	 * Create an object that will contain all the solutions of the synthesis.
	 * @param config - setup configuration for the synthesis.
	 */
	public All_SAT_solutions(APEConfig config) {
		solutionWorkflow = new ArrayList<SolutionWorkflow>();
		
		/** Provides mapping from each atom to a number, and vice versa */
		mappings = new AtomMapping();
		/*
		 * Variables defining the current and maximum lengths and solutions count.
		 */
		solutionsFoundMax = config.getMax_no_solutions();
		if(solutionsFoundMax > 1000) {
			System.out.println("Looking for " + solutionsFoundMax + " solutions might take some time.");
		}
	}

	/**
	 * Get all the solutions that are currently found.
	 * @return List of {@link SolutionWorkflow solution} objects
	 */
	public List<SolutionWorkflow> getSolutions() {
		return solutionWorkflow;
	}

	/** 
	 * Get the number of solutions that are currently found.
	 * @return Number of solutions in the solutions set.
	 */
	public int getNumberOfSolutions() {
		return solutionWorkflow.size();
	}

	/**
	 * Get max number of solutions that should be found. This number is defined in the ape.config file.
	 * @return Max number of solutions that should be found.
	 */
	public int getMaxNumberOfSolutions() {
		return solutionsFoundMax;
	}

	/**
	 * Get object that contains mappings of all the atoms.
	 * @return {@link AtomMapping} object.
	 */
	public AtomMapping getMappings() {
		return mappings;
	}
	/**
	 * Returns true if the list of all the solutions contains no elements.
	 * @return {@code true} if the list contains no elements
	 */
	public boolean isEmpty() {
		return solutionWorkflow.isEmpty();
	}
	
	/**
	 * The procedure resets the encodings specific for a synthesis run (such as auxiliary variables).
	 */
	public void newEncoding() {
		mappings.resetAuxVariables();
	}

	/**
	 * Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
	 * 
	 * @param currSolutions - solutions that should be added to the list of all solutions
	 * @return {@code true} if this list changed as a result of the call
	 */
	public boolean addSolutions(List<SolutionWorkflow> currSolutions) {
		if(solutionWorkflow.addAll(currSolutions)) {
			return true;
		}
		return false;
	}


	public SolutionWorkflow get(int index) {
		return solutionWorkflow.get(index);
	}
}
