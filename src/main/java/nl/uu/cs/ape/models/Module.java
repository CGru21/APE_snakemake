package nl.uu.cs.ape.models;

import org.json.JSONException;
import org.json.JSONObject;

import lombok.Getter;
import nl.uu.cs.ape.domain.APEDimensionsException;
import nl.uu.cs.ape.domain.APEDomainSetup;
import nl.uu.cs.ape.utils.APEUtils;
import nl.uu.cs.ape.models.enums.LogicOperation;
import nl.uu.cs.ape.models.enums.NodeType;
import nl.uu.cs.ape.models.logic.constructs.TaxonomyPredicate;

import java.util.*;

/**
 * The {@code Module} class represents concrete modules/tools that can be used
 * in our program. It must be annotated using the proper Input/Output pair
 * provided by the tool annotation file.
 *
 * @author Vedran Kasalica
 */
public class Module extends AbstractModule {

    /**
     * List of input types required by the tool.
     */
    private List<Type> moduleInput;

    /**
     * List of input keys used in the CWL file.
     * This is used to map the input types to the CWL inputs. In case CWL file was not
     * used to create the module, this list will be {@code null}.
     */
    private List<String> moduleCWLInputKeys = null;

    /**
     * List of output types generated by the tool.
     */
    private List<Type> moduleOutput;

    /**
     * List of output keys used in the CWL file.
     * This is used to map the output types to the CWL outputs. In case CWL file was not
     * used to create the module, this list will be {@code null}.
     */
    private List<String> moduleCWLOutputKeys = null;

    /**
     * Reference  to the CWL file that describes the module.
     */
    @Getter
    private final String cwlFileReference;

    /**
     * A string containing a command line execution command.
     */
    @Getter
    private final String executionCommand;


    /**
     * Constructs a new Module with already defined lists of input and output types.
     *
     * @param moduleName      Name of the module.
     * @param moduleID        ID of the module.
     * @param rootNode        ID of the Taxonomy Root associated with the Module.
     * @param moduleInput     List of the INPUT types/formats.
     * @param moduleOutput    List of the OUTPUT types/formats.
     * @param cwlReference    Reference to the CWL file that describes the module.
     * @param moduleExecution Command that is used to execute the tool from the
     *                        command line.
     */
    public Module(String moduleName, String moduleID, String rootNode, List<Type> moduleInput,
            List<Type> moduleOutput,String cwlReference, String moduleExecution) {
        super(moduleName, moduleID, rootNode, NodeType.LEAF);
        this.moduleInput = new ArrayList<>(moduleInput);
        this.moduleOutput = new ArrayList<>(moduleOutput);
        this.cwlFileReference = cwlReference;
        this.executionCommand = moduleExecution;
    }

    /**
     * Constructs a new Module with empty lists of input and output types/formats.
     *
     * @param moduleName      Name of the module.
     * @param moduleID        Unique module identifier.
     * @param rootNode        ID of the Taxonomy Root node corresponding to the
     *                        Module.
     * @param cwlReference    Reference to the CWL file that describes the module.
     * @param executionCode   Command that is used to execute the tool from the
     *                        command line.
     */
    public Module(String moduleName, String moduleID, String rootNode, String cwlReference, String executionCode) {
        super(moduleName, moduleID, rootNode, NodeType.LEAF);
        this.moduleInput = new ArrayList<>();
        this.moduleOutput = new ArrayList<>();
        this.cwlFileReference = cwlReference;
        this.executionCommand = executionCode;
    }

    /**
     * Constructor used to override an existing AbstractModule with a new Module.
     *
     * @param module         New created Module.
     * @param abstractModule Existing AbstractModule that is to be extended with all
     *                       the fields from the Module.
     */
    public Module(Module module, TaxonomyPredicate abstractModule) {
        super(abstractModule, NodeType.LEAF);
        this.moduleInput = module.getModuleInput();
        this.moduleOutput = module.getModuleOutput();
        this.cwlFileReference = module.getCwlFileReference();
        this.executionCommand = module.getExecutionCommand();
    }

    /**
     * Returns the list (possibly empty) of required input types for the module.
     * Returns null in the case of abstract classes, as they do not have input
     * types.
     *
     * @return List of input types (tool modules) or null (non-tool/abstract
     *         modules).
     */
    @Override
    public List<Type> getModuleInput() {
        return moduleInput;
    }

    /**
     * Sets module input.
     *
     * @param moduleInputs the module inputs
     */
    public void setModuleInput(List<Type> moduleInputs) {
        this.moduleInput = moduleInputs;
    }

    /**
     * Appends the specified element to the end of the input list (optional
     * operation).
     *
     * @param moduleInput Element to be appended to this list.
     */
    public void addModuleInput(Type moduleInput) {
        this.moduleInput.add(moduleInput);
    }


    /**
     * Returns the list (possibly empty) of required output types for the module.
     * Returns null in the case of abstract classes, as they do not have output
     * types.
     *
     * @return List of output types (tool modules) or null (non-tool/abstract
     *         modules).
     */
    @Override
    public List<Type> getModuleOutput() {
        return moduleOutput;
    }

    /**
     * Sets module output.
     *
     * @param moduleOutput the module output
     */
    public void setModuleOutput(List<Type> moduleOutput) {
        this.moduleOutput = moduleOutput;
    }

    /**
     * Appends the specified element to the end of the output list (optional
     * operation).
     *
     * @param moduleOutput Element to be appended to this list.
     */
    public void addModuleOutput(Type moduleOutput) {
        this.moduleOutput.add(moduleOutput);
    }

    /**
     * Returns the list of input keys used in the CWL file.
     * This is used to map the input types to the CWL inputs.
     *
     * @return List of input keys used in the CWL file.
     */
    public List<String> getModuleCWLInputKeys() {
        return moduleCWLInputKeys;
    }

    /**
     * Sets the list of input keys used in the CWL file.
     * This is used to map the input types to the CWL inputs.
     *
     * @param moduleCWLInputKeys List of input keys used in the CWL file.
     */
    public void setModuleCWLInputKeys(List<String> moduleCWLInputKeys) {
        this.moduleCWLInputKeys = moduleCWLInputKeys;
    }

    /**
     * Returns the list of output keys used in the CWL file.
     * This is used to map the output types to the CWL outputs.
     *
     * @return List of output keys used in the CWL file.
     */
    public List<String> getModuleCWLOutputKeys() {
        return moduleCWLOutputKeys;
    }

    /**
     * Sets the list of output keys used in the CWL file.
     * This is used to map the output types to the CWL outputs.
     *
     * @param moduleCWLOutputKeys List of output keys used in the CWL file.
     */
    public void setModuleCWLOutputKeys(List<String> moduleCWLOutputKeys) {
        this.moduleCWLOutputKeys = moduleCWLOutputKeys;
    }

    /**
     * Generate a taxonomy tool instance that is referenced in the json.
     * 
     * @param jsonParam JSON object that contains the abstract module information.
     * @param domainSetup APE domain information.
     * @return A AbstractModule object that represent the data instance given as the
     *         parameter.
     * @throws JSONException          if the given JSON is not well formatted
     * @throws APEDimensionsException if the referenced modules are not well defined
     */
    public static AbstractModule taxonomyInstanceFromJson(JSONObject jsonParam, APEDomainSetup domainSetup)
            throws JSONException {
        /* Set of predicates where each describes a type dimension */
        SortedSet<TaxonomyPredicate> parameterDimensions = new TreeSet<>();
        AllModules allModules = domainSetup.getAllModules();
        /* Iterate through each of the dimensions */
        for (String currRootLabel : jsonParam.keySet()) {
            String curRootIRI = currRootLabel;
            if (!allModules.existsRoot(curRootIRI)) {
                curRootIRI = APEUtils.createClassIRI(currRootLabel, domainSetup.getOntologyPrefixIRI());
            }
            if (!allModules.existsRoot(curRootIRI)) {
                throw APEDimensionsException
                        .notExistingDimension("Data type was defined over a non existing data dimension: '" + curRootIRI
                                + "', in JSON: '" + jsonParam + "'");
            }
            LogicOperation logConn = LogicOperation.OR;
            SortedSet<TaxonomyPredicate> logConnectedPredicates = new TreeSet<TaxonomyPredicate>();
            /* for each dimensions a disjoint array of types/tools is given */
            for (String currModuleLabel : APEUtils.getListFromJson(jsonParam, currRootLabel, String.class)) {
                String currModuleIRI = APEUtils.createClassIRI(currModuleLabel, domainSetup.getOntologyPrefixIRI());

                AbstractModule currModule = allModules.get(currModuleIRI);
                if (currModule == null) {
                    currModule = allModules.get(currModuleLabel);
                }

                if (currModule != null) {
                    /*
                     * if the type exists, make it relevant from the taxonomy perspective and add it
                     * to the outputs
                     */
                    currModule.setAsRelevantTaxonomyTerm(allModules);
                    logConnectedPredicates.add(currModule);
                } else {
                    throw APEDimensionsException.dimensionDoesNotContainClass(String.format(
                            "Error in a JSON input, the tool '%s' is not recognized. \nPotential reasons: \n1) there is no tool annotatied with the specified name or \n2) the tool does not belong to the tool dimension '%s'.",
                            currModuleIRI, curRootIRI));
                }
            }

            /*
             * Create a new type, that represents a disjunction of the types, that can be
             * used to abstract over each of the types individually and represents
             * specification over one dimension.
             */
            AbstractModule abstractDimensionType = AuxModulePredicate.generateAuxiliaryPredicate(logConnectedPredicates,
                    logConn, domainSetup);
            if (abstractDimensionType != null) {
                parameterDimensions.add(abstractDimensionType);
            }

        }
        AbstractModule taxonomyInstance = AuxModulePredicate.generateAuxiliaryPredicate(parameterDimensions,
                LogicOperation.AND, domainSetup);

        return taxonomyInstance;
    }

    /**
     * Return a printable String version of the module.
     *
     * @return Module as printable String.
     */
    @Override
    public String toString() {
        StringBuilder inputs = new StringBuilder();
        StringBuilder outputs = new StringBuilder();

        for (Type inType : moduleInput) {
            inputs.append("{").append(inType.toShortString()).append("} ");
        }
        for (Type outType : moduleOutput) {
            outputs.append("{").append(outType.toShortString()).append("} ");
        }

        return "______________________________________\n|"
                + super.toString() +
                ",\n|IN:\t" + inputs +
                ",\n|OUT\t" + outputs +
                "\n|______________________________________";
    }

    /**
     * Print the ID of the Module with a label [T] in the end (denoting Tool).
     *
     * @return ID of the Module.
     */
    @Override
    public String toShortString() {
        return super.toShortString(); // + "[T]";
    }

    @Override
    public String getType() {
        return "module";
    }
}
